{"name":"Refluxmanifesto","tagline":"Thoughts on using Reflux as I try to come to terms with it","body":"# Reflux Manifesto\r\nThoughts on using Reflux as I try to come to terms with it.\r\n\r\n## Actions:\r\n  * [New Data](#new-data) **always** enters through actions\r\n  * Actions represent one half of the [Public API](#public-api) of your business domain.\r\n  * Actions do no modelling, Stores do.\r\n    * Don't read state from a store, that sounds like we're mixing business logic in actions.\r\n    * Don't respond to the payload from components, that's also business logic.\r\n  * Do not listen to stores (although stores can trigger actions)\r\n\r\n## Stores:\r\n  * Where the business domain model belongs\r\n  * Can have direct method calls from other business modelling (other stores)\r\n  * Can contain [state](#state) that matters for business domain modelling\r\n    * Don't put everything in here. Just the stuff you need to persist for business decisions. \r\n  * Stores can be dependent on [multiple events occuring](https://github.com/spoike/refluxjs#joining-parallel-listeners-with-composed-listenables)\r\n    * from actions\r\n    * from other stores\r\n  * [Shared modelling](#shared-modelling) should be composed into mixins\r\n  * Emit events so that views and other stores can react to changes.\r\n  * Emit action events so that other dataflows can be triggered. [I have some concerns](#stores-triggering-actions)\r\n\r\n## Components:\r\n   * Are dumb or smart\r\n   * Smart == ViewController\r\n     * Map view events to Actions\r\n     * Call Actions during component lifecycle - e.g. componentWillMount\r\n     * Map Store Events to setState, causing invalidation\r\n   * Dumb == Business Domain Free components, they talk about UI things, not business things\r\n     * Know nothing of your Actions or stores\r\n     * Are mutated via parent 'ViewControllers' setting proprties or state.\r\n\r\n# Notes\r\n\r\n## New Data\r\n\r\nNew data can:\r\n  * Result from user actions\r\n  * Result from service results\r\n  * Result from domain changes (eg the hashchange event)\r\n\r\nEven without new data, if the view wants state to change (eg SomeThing.toggleSelected), do so through actions.\r\n\r\n## Public API\r\n\r\nYour business domain get's a clear public API comprised of:\r\n  * Actions: which are the only cause for state mutation.\r\n  * Store Events: which allow ViewControllers to respond to changes in state\r\n  * Store State: Which allows views to refresh based on state regardless of wether store events occured\r\n \r\nI'm not sure about reading state from the stores. It might be possible to avoid using it in views, and keep the interface very narrow indeed.\r\n\r\n## Shared Modelling\r\nFrom [An Issue](https://github.com/spoike/refluxjs/issues/252) where Spoike discusses typical store->component updates and shared behaviour.\r\n\r\n> `trigger` passes the arguments over to the listeners... and I personally prefer to pass all the data that the components need through the event. I have passed the store itself (for quick prototype hacks) and use setters and getters. Both approaches are equal valid implementations and I don't want to enforce one over the other.\r\n\r\n> However I don't personally encourage the latter approach (of setters and getters on the store) since that usually has been a slipper slope to create stores that are \"god classes\". \"God class\" or \"big ball of mud\" are anti-patterns that I like to avoid.\r\n\r\n> As to how to reuse, I use mixins when applicable. If you think about them as traits, it makes it easy to attach functionality that you may want to reuse. If you need to add common methods to all stores you may add them to the `Reflux.StoreMixin` which is used during creation of stores.\r\n\r\n## State\r\n\r\nSpoike suggests:\r\n> > As far as Flux goes is it okay to store the global var map = Object instance inside a store as a plain JS variable and then have a getter/setter action to get that map instance across multiple components in my app, including Maps component itself?\r\n\r\n> Sure, if that works for you then it is okay. Stores are supposed to hold all the data that the components need between each other.\r\n\r\nI'm of the opinion that you would try to avoid storing a whole map component (google map object), and have a controller view share it's state with the business model through busines-centric actions. This way you find yourself modelling your domain, not Googles. \r\n\r\n## Stores triggering actions\r\nThis one seems like it could become hard to reason about.\r\n\r\nMy concern is that this would introduce an action that:\r\n  * is triggered without new information being introduced into the business modelling\r\n  * is possibly only a 'sub-flow' of the public API, making it something that views would never directly consume, ergo, not a Public API\r\n\r\nI want to use these, they seem valuable.\r\n\r\n[There is a discussion here](https://github.com/spoike/refluxjs/issues/158#issuecomment-67444098)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}